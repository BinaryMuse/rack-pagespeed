<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>rack-pagespeed, a "port" of modpagespeed to Rack</title>
    <meta name="description" content="a Rack middleware that optimizes web pages, inspired by modpagespeed" />
    <meta name="author" content="Awesome By Design" />
    <meta name="viewport" content="width=device-width; initial-scale=1.0; maximum-scale=1.0;" />
    <link rel="shortcut icon" href="/favicon.ico" />
    <link rel="stylesheet" href="css/rack-pagespeed.css" />
    <script src="js/modernizr-1.6.min.js"></script>
    <script type="text/javascript" src="http://use.typekit.com/qno6yyg.js"></script>
    <script type="text/javascript">try{Typekit.load();}catch(e){}</script>
  </head>
  <!--[if lt IE 7 ]> <body class="ie6"> <![endif]-->
  <!--[if IE 7 ]>    <body class="ie7"> <![endif]-->
  <!--[if IE 8 ]>    <body class="ie8"> <![endif]-->
  <!--[if IE 9 ]>    <body class="ie9"> <![endif]-->
  <!--[if (gt IE 9)|!(IE)]><!--> <body> <!--<![endif]-->
    <div id="wrapper">
      <header>
        <p>Instructions manual</p>
        <h1>
          RACK-PAGESPEED
        </h1>
      </header>
      <section id="intro">
        <p>
          rack-pagespeed is a Rack middleware that helps reduce the time it takes for your web page/app to load.
        </p>
        <p>
          How does it do that? It runs the output HTML through filters that apply a series of best practices
          automatically for you.
        </p>
      </section>
      <div class="clearfix"></div>
      <ul id="filters">
        <li>
          <h1>Inline JavaScripts</h1>
          <p>
            Inlines external JavaScripts that are smaller
            than 2 kilobytes.
          </p>
          <code>
            inline_javascripts
              <span class="options">:max_size => &lt;bytes&gt;</span>
          </code>
        </li>
        <li>
          <h1>Inline CSS</h1>
          <p>
            Inlines external stylesheets that are smaller
            than 2 kilobytes.
          </p>
          <code>
            inline_css
              <span class="options">:max_size => &lt;bytes&gt;</span>
          </code>
        </li>
        <li>
          <h1>Combine JavaScripts</h1>
          <p>
            Merges neighbouring JavaScripts together.
          </p>
          <code>
            combine_javascripts
          </code>
        </li>
        <li>
          <h1>Combine CSS</h1>
          <p>
            Merges neighbouring stylesheets together.
          </p>
          <code>
            combine_css
          </code>
        </li>
        <li>
          <h1>Minify JavaScripts</h1>
          <p>
            Minifies (compresses) JavaScripts.
          </p>
          <code>
            minify_javascripts
          </code>          
        </li>
        <li class="wip">
          <h1>Inline Images</h1>
          <p>
            Inlines small images using data URI.
          </p>
        </li>
      </ul>
      <section id="instructions" class="regular">
        <h1>Installation and usage</h1>
        <p>Install via rubygems:</p>
        <code>$ gem install rack-pagespeed</code>
        <p>Example usage with Sinatra (in a rackup file, a.k.a. config.ru)</p>
        <code>
          require 'rack/pagespeed'<br />
          require 'myapp'<br />
          use Rack::PageSpeed, :public => "/app/public/dir" do<br />
            <span class="indent">store :disk => Dir.tmpdir # require 'tmpdir'</span><br />
            <span class="indent">inline_javascript :max_size => 4000</span><br />
            <span class="indent">inline_css</span><br />
            <span class="indent">combine_javascripts</span><br />
          end<br />
          run Sinatra::Application
        </code>
        <p>Usage with Rails:</p>
        <code>
          something
        </code>
        <p>
          In a nutshell: invoke the filters you want and pass them parameters.
          rack-pagespeed will then figure out the best order of execution and run
          the filters you invoked against the document.
        </p>
      </section>
      <section id="explain-filters" class="regular reverse">
        <h1>Filters</h1>
        <p>
          Filters modify the document in some way. The default filters are heavily inspired (or borrowed even, if you will) from
          Google's <a>modpagespeed</a>, for the <a>Apache web server</a>. I believe though that, as much as this middleware is
          slower than it, it's useful for at least 2 scenarios: when you don't have control over the web server, or when your
          web server isn't Apache. I can also come up with customized excuses if you need any.
        </p>
        <p>
          Rolling your own filter is easy: subclass <code>Rack::PageSpeed::Filter</code>, define a <code>#execute!</code> method
          on your class which takes a Nokogiri HTML document as parameter, and you're set. For example:
        </p>
        <code>
          class RemovesImages &lt; Rack::PageSpeed::Filter<br />
            <span class="indent">def execute! document</span><br />
              <span class="indent">
                <span class="indent">document.css('img').remove if rand(99) > @options[:chance] - 1</span>
              </span><br />
            <span class="indent">end</span><br />
          end
        </code>
        <p>
          It doesn't matter where you define the class, as long as you do it before invoking it, perhaps in a separate file
          which you'll <code>#require</code> or even inside the block where you invoke the filters. Wherever it is, rack-pagespeed
          will know where to find it.
        </p>
        <p>So after declaring, you can call it like so:</p>
        <code>
          use Rack::PageSpeed, :public => "/app/public/dir" do<br />
            <span class="indent">remove_images :chance => 50</span><br />
          end
        </code>
        <p>
          rack-pagespeed will create a method out of the class name that looks much like what comes out of Rails' <code>#underscore</code>
          method. Any options that you pass (do pass a Hash), if any, will be accessible via <code>@options</code>.
        </p>
      </section>
      <section id="storage" class="regular">
        <h1>Storage</h1>
        <p>
          Some filters may require some kind of storage where they can keep the result of their process. For example, the
          <code>combine_javascripts</code> filter, in order to make the results of it's process available, it will:
        </p>
        <ol>
          <li>join neighbouring JavaScripts it finds.</li>
          <li>put their joined contents in storage.</li>
          <li>
            replace the references to each individual script file in the HTML for a special URL which rack-pagespeed can
            use to locate the joined result saved in storage. It looks like
            <code>/rack-pagespeed-098f6bcd4621d373cade4e832627b4f6.js</code>.
          </li>
        </ol>
        <p>
          So now instead of, say, 4 separate HTTP requests (one for each script), the browser will make 1, which rack-pagespeed
          will intercept and serve the bundle instead.
        </p>
        <p>
          There's two types of storage available by default: disk storage (file system), and <a>Memcached</a>.
          You can use them like this:
        </p>
        <code>
          use Rack::PageSpeed, :public => "/app/public/dir" do<br />
            <span class="indent">store :disk</span> # defaults to Dir.tmpdir<br />
            <span class="indent"># or</span><br />
            <span class="indent">store :disk => "/path/to/some/dir"</span><br />
            <span class="indent"># or</span><br />
            <span class="indent">store :memcached # defaults to localhost:11211</span><br />
            <span class="indent"># or</span><br />
            <span class="indent">store :memcached => 'address:port'</span>
        </code>
        <p>
          Neat trick: if your app can write to it's public dir, if you call <code>store :disk => "app's public dir"</code>,
          requests for bundled/compressed assets won't even hit the application stack. Meaning, huge performance gains.
        </p>
      </section>
      <section id="caveats" class="regular reverse">
        <h1>Caveats & issues</h1>
        <p>
          I'll call it for what it is: rack-pagespeed is to be considered alpha at this stage. Meaning: make sure you do at least
          a cursory check to ensure everything's working after you include this middleware in your stack. I'll happily look into
          <a href="https://github.com/juliocesar/rack-pagespeed/issues">issues reported via GitHub</a> or
          <a href="mailto:julio@awesomebydesign.com">email</a>.
        </p>
        <p>Stuff to bear in mind:</p>
        <ul>
          <li>
            Filters will run every time a response of type <code>text/html</code> is issued by your application. While that might
            concern some, I found them to be pretty cheap on the memory/CPU side, so well worth using even if you're not caching
            things properly...
          </li>
          <li>
            ... and speaking of caching, most sane web servers will issue <code>304 Not Modified</code> in subsequent requests
            for a document. In this case, rack-pagespeed won't even see, and hence, won't run any filters on it.
          </li>
          <li>
            The web page/app performance equation is terribly complex. Though given nowadays' reality of latency and/or low bandwidth,
            minimizing the number of requests a web browser has to make is a safe bet towards improving it.
          </li>
        </ul>
      </section>
      <section id="moi" class="regular">
        <h1>Author</h1>
        <p>
          rack-pagespeed is made with <span class="heart">â™¥</span> by <a href="http://awesomebydesign.com">Julio Cesar Ody</a>.
          All code is public domain. This page's design however, is not.
        </p>
      </section>
    </div>
  </body>
</html>